== Creating Validated Patterns
include::_attributes.adoc[]

include::main@vp-workshop:ROOT:partial$topicHeader.adoc[]

* Understanding `common`
* Pattern Requirements
* Creation Process

[IMPORTANT]
.Core Concepts
====
* **Creating is Extending** We never really create a new pattern from zero. Instead we extend our basic pattern using artifacts that we have developed along the way
* **Artifacts** Artifacts can include Helm Charts, Kustomize manifests, or plain Kubernetes manifests
* **Moving Artifacts into the Validated Patterns framework** Many artifacts require conversion to Helm chart templates and parameterizing certain values
* **Helm** Helm is a kubernetes package manager that allows you to define, install and manage kubernetes applications as reusable packages called charts
====

[#common]
== Understanding common

What's the role of the **common** repository?
* The core components that make up the Validated Patterns framework are contained in the common repository
* Including:
** OpenShift GitOps configurations
** RHACM configuration and Global Policies
*** Support for **clusterGroup** and **GitOps** policies
** Validated Pattern build scripts and Makefiles
** Secrets Management (Hashicorp Vault)
** Operator CRDs and other assets
** Various utility scripts

What's in common? 

NOTE: The common repository is where all the common manifests for the Validated Patterns framework live

* **acm** - contains the helm charts, which contains policies and is used to configure the deployment of the {rhacm}
* **clusterGroup** - contains the helm charts used to create namespaces, subscriptions, Argo Project and Applications described in values files. THis is the seed for all the patterns.
* **operator-install** - contains the helm chart used by the Validated Patterns operator to create the openshift-gitops component, creating the initial ArgoCD applications for Validated Patterns.

[source,bash]
----
common
├── acm
├── ansible
├── Changes.md
├── clustergroup
├── common -> .
├── examples
├── golang-external-secrets
├── hashicorp-vault
├── LICENSE
├── Makefile
├── letsencrypt
├── operator-install
├── README.md
├── reference-output.yaml
├── scripts
├── super-linter.log
├── tests
└── values-global.yaml
----

* **ansible** - this directory contains the ansible roles and modules that support the secrets management for a pattern
* **hashicorp-vault** - contains the helm chart for {vault}
* **scripts** - contains utility scripts used by the Validated Patterns Framework
* **golang-external-secrets** - Helm chart for the {eso}

=== What's next for common?

* We are in the very early stages of moving the helm charts in common into a public Helm repository
* Deploying our patterns with multi-source enabled which allows us to use multiple sources for values, which will help reduce the need to have all the charts in the repo
* Continue to maintain Makefiles, Ansible scripts and other tools in this repo in support of deploying patterns

[#Creation Process]
== Creation Process

image::create-where2start.png[]

One of the first things we should do before embarking on creating a pattern is to identify a problem to solve. This can come from an existing customer problem or an idea on how we can showcase some of our Red Hat products working together. You can use one of our simplest validated patterns, multicloud gitops, as a starting point by using the template to create a new Git repository in your local GitHub account.  You might already have an existing demo that you can use and convert it to use the Validated Pattern framework.

The next step is to identify the technology components that you will need.  In the case of an existing demo you might already know which components are part of the pattern. 

The final step is to ensure that the configuration of those components, and the integration points, are handled in the pattern.  
